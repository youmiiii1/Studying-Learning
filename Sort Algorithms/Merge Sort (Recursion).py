def merge_sort(lst: list[int]) -> list[int]:
    if len(lst) <= 1:                                       # Если длина списка меньше чем один объект, заканчиваем цикл "Предотвращаем бесконечный цикл"
        return lst
    mid = len(lst) // 2                                     # Переменная (mid), делим список на 2 части / пополам
    left = merge_sort(lst[:mid])                            # Переменная (left) сохраняем первую часть списка, все что находится слева "рекурсивно вызываем функцию еще раз, делим пока не выполнится базовый случай"
    right = merge_sort(lst[mid:])                           # Переменная (right) сохраняем вторую часть списка, все что находится справа "рекурсивно вызываем функцию еще раз, делим пока не выполнится базовый случай"
    return merge(left, right)                               # Рекурсивно запускаем функцию (merge), в аргументы передаем 2 части списка (left) (right)

def merge(left: list[int], right: list[int]) -> list[int]:
    result = []                                 # Переменная / Список (result), в него записываем и храним уже отсортированные данные
    i = j = 0                                   # Переменные (i) и (j), указатели / текущая позиция "показывает, где мы находимся в списке left и right"
    while i < len(left) and j < len(right):     # Пока (i) меньше чем количество объектов в левом списке и (j) меньше чем количество объектов в правом списке "Работает, пока в обоих списках есть элементы. Как только один список заканчивается — переходим к extend."
        if left[i] < right[j]:                  # Сравнение текущих элементов двух списков (left и right), на которых сейчас стоят указатели i и j
            result.append(left[i])              # Если объект в левом списке за индексом (i) больше чем объект в правом списке за индексом (j) тогда мы добавляем объект из левого списка в список (result)
            i += 1                              # Двигаем (i) на следующий объект
        else:
            result.append(right[j])             # Если объект в правом списке за индексом (j) больше чем объект в левом списке за индексом (i) тогда мы добавляем объект из правого списка в список (result)
            j += 1                              # Двигаем (j) на следующий объект
                                                # Добавляем в список (result) всё, что осталось в каждом списке (left) и (right) --->
    result.extend(left[i:])
    result.extend(right[j:])
    return result

temp = [-20, 10, -10, 5, 20, 30, 25]
print(merge_sort(temp))